const ut=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Re(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Yt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Bt(t,...n){if(!Re(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}function Ze(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Yt(t.outputLen),Yt(t.blockLen)}function Lt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function ze(t,n){Bt(t);const e=n.outputLen;if(t.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function gt(...t){for(let n=0;n<t.length;n++)t[n].fill(0)}function Zt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function W(t,n){return t<<32-n|t>>>n}function ke(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function $t(t){return typeof t=="string"&&(t=ke(t)),Bt(t),t}function Ve(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];Bt(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const s=t[r];e.set(s,o),o+=s.length}return e}class ue{}function Xt(t){const n=r=>t().update($t(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Me(t=32){if(ut&&typeof ut.getRandomValues=="function")return ut.getRandomValues(new Uint8Array(t));if(ut&&typeof ut.randomBytes=="function")return Uint8Array.from(ut.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qt=BigInt(0),Kt=BigInt(1);function At(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Jt(t){if(!At(t))throw new Error("Uint8Array expected")}function mt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function It(t){const n=t.toString(16);return n.length&1?"0"+n:n}function he(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Qt:BigInt("0x"+t)}const be=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ge=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function Et(t){if(Jt(t),be)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Ge[t[e]];return n}const $={_0:48,_9:57,A:65,F:70,a:97,f:102};function ne(t){if(t>=$._0&&t<=$._9)return t-$._0;if(t>=$.A&&t<=$.F)return t-($.A-10);if(t>=$.a&&t<=$.f)return t-($.a-10)}function Ot(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(be)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){const f=ne(t.charCodeAt(s)),c=ne(t.charCodeAt(s+1));if(f===void 0||c===void 0){const i=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}r[o]=f*16+c}return r}function ct(t){return he(Et(t))}function we(t){return Jt(t),he(Et(Uint8Array.from(t).reverse()))}function vt(t,n){return Ot(t.toString(16).padStart(n*2,"0"))}function ge(t,n){return vt(t,n).reverse()}function j(t,n,e){let r;if(typeof n=="string")try{r=Ot(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(At(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function qt(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];Jt(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const s=t[r];e.set(s,o),o+=s.length}return e}const zt=t=>typeof t=="bigint"&&Qt<=t;function te(t,n,e){return zt(t)&&zt(n)&&zt(e)&&n<=t&&t<e}function wt(t,n,e,r){if(!te(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function De(t){let n;for(n=0;t>Qt;t>>=Kt,n+=1);return n}const Ct=t=>(Kt<<BigInt(t))-Kt,kt=t=>new Uint8Array(t),re=t=>Uint8Array.from(t);function Fe(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=kt(t),o=kt(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},c=(...h)=>e(o,r,...h),i=(h=kt(0))=>{o=c(re([0]),h),r=c(),h.length!==0&&(o=c(re([1]),h),r=c())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const p=[];for(;h<n;){r=c();const H=r.slice();p.push(H),h+=r.length}return qt(...p)};return(h,p)=>{f(),i(h);let H;for(;!(H=p(d()));)i();return f(),H}}const je={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||At(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function _t(t,n,e={}){const r=(o,s,f)=>{const c=je[s];if(typeof c!="function")throw new Error("invalid validator function");const i=t[o];if(!(f&&i===void 0)&&!c(i,t))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+i)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}function oe(t){const n=new WeakMap;return(e,...r)=>{const o=n.get(e);if(o!==void 0)return o;const s=t(e,...r);return n.set(e,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const F=BigInt(0),M=BigInt(1),ft=BigInt(2),Ye=BigInt(3),xe=BigInt(4),pe=BigInt(5),ye=BigInt(8);function Y(t,n){const e=t%n;return e>=F?e:n+e}function Wt(t,n){if(t===F)throw new Error("invert: expected non-zero number");if(n<=F)throw new Error("invert: expected positive modulus, got "+n);let e=Y(t,n),r=n,o=F,s=M;for(;e!==F;){const c=r/e,i=r%e,d=o-s*c;r=e,e=i,o=s,s=d}if(r!==M)throw new Error("invert: does not exist");return Y(o,n)}function me(t,n){const e=(t.ORDER+M)/xe,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function Ke(t,n){const e=(t.ORDER-pe)/ye,r=t.mul(n,ft),o=t.pow(r,e),s=t.mul(n,o),f=t.mul(t.mul(s,ft),o),c=t.mul(s,t.sub(f,t.ONE));if(!t.eql(t.sqr(c),n))throw new Error("Cannot find square root");return c}function We(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-M,e=0;for(;n%ft===F;)n/=ft,e++;let r=ft;const o=St(t);for(;ie(o,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return me;let s=o.pow(r,n);const f=(n+M)/ft;return function(i,d){if(i.is0(d))return d;if(ie(i,d)!==1)throw new Error("Cannot find square root");let x=e,h=i.mul(i.ONE,s),p=i.pow(d,n),H=i.pow(d,f);for(;!i.eql(p,i.ONE);){if(i.is0(p))return i.ZERO;let q=1,w=i.sqr(p);for(;!i.eql(w,i.ONE);)if(q++,w=i.sqr(w),q===x)throw new Error("Cannot find square root");const T=M<<BigInt(x-q-1),C=i.pow(h,T);x=q,h=i.sqr(C),p=i.mul(p,h),H=i.mul(H,C)}return H}}function Pe(t){return t%xe===Ye?me:t%ye===pe?Ke:We(t)}const $e=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Xe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=$e.reduce((r,o)=>(r[o]="function",r),n);return _t(t,e)}function Qe(t,n,e){if(e<F)throw new Error("invalid exponent, negatives unsupported");if(e===F)return t.ONE;if(e===M)return n;let r=t.ONE,o=n;for(;e>F;)e&M&&(r=t.mul(r,o)),o=t.sqr(o),e>>=M;return r}function Ee(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),o=n.reduce((f,c,i)=>t.is0(c)?f:(r[i]=f,t.mul(f,c)),t.ONE),s=t.inv(o);return n.reduceRight((f,c,i)=>t.is0(c)?f:(r[i]=t.mul(f,r[i]),t.mul(f,c)),s),r}function ie(t,n){const e=(t.ORDER-M)/ft,r=t.pow(n,e),o=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),f=t.eql(r,t.neg(t.ONE));if(!o&&!s&&!f)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function Be(t,n){n!==void 0&&Yt(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function St(t,n,e=!1,r={}){if(t<=F)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:s}=Be(t,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const c=Object.freeze({ORDER:t,isLE:e,BITS:o,BYTES:s,MASK:Ct(o),ZERO:F,ONE:M,create:i=>Y(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return F<=i&&i<t},is0:i=>i===F,isOdd:i=>(i&M)===M,neg:i=>Y(-i,t),eql:(i,d)=>i===d,sqr:i=>Y(i*i,t),add:(i,d)=>Y(i+d,t),sub:(i,d)=>Y(i-d,t),mul:(i,d)=>Y(i*d,t),pow:(i,d)=>Qe(c,i,d),div:(i,d)=>Y(i*Wt(d,t),t),sqrN:i=>i*i,addN:(i,d)=>i+d,subN:(i,d)=>i-d,mulN:(i,d)=>i*d,inv:i=>Wt(i,t),sqrt:r.sqrt||(i=>(f||(f=Pe(t)),f(c,i))),toBytes:i=>e?ge(i,s):vt(i,s),fromBytes:i=>{if(i.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+i.length);return e?we(i):ct(i)},invertBatch:i=>Ee(c,i),cmov:(i,d,x)=>x?d:i});return Object.freeze(c)}function Ae(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ve(t){const n=Ae(t);return n+Math.ceil(n/2)}function Je(t,n,e=!1){const r=t.length,o=Ae(n),s=ve(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const f=e?we(t):ct(t),c=Y(f,n-M)+M;return e?ge(c,o):vt(c,o)}function tn(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(e>>o&s),c=Number(e&s),i=r?4:0,d=r?0:4;t.setUint32(n+i,f,r),t.setUint32(n+d,c,r)}function en(t,n,e){return t&n^~t&e}function nn(t,n,e){return t&n^t&e^n&e}class Se extends ue{constructor(n,e,r,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.buffer=new Uint8Array(n),this.view=Zt(this.buffer)}update(n){Lt(this),n=$t(n),Bt(n);const{view:e,buffer:r,blockLen:o}=this,s=n.length;for(let f=0;f<s;){const c=Math.min(o-this.pos,s-f);if(c===o){const i=Zt(n);for(;o<=s-f;f+=o)this.process(i,f);continue}r.set(n.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){Lt(this),ze(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;e[f++]=128,gt(this.buffer.subarray(f)),this.padOffset>o-f&&(this.process(r,0),f=0);for(let h=f;h<o;h++)e[h]=0;tn(r,o-8,BigInt(this.length*8),s),this.process(r,0);const c=Zt(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=i/4,x=this.get();if(d>x.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)c.setUint32(4*h,x[h],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:f,pos:c}=this;return n.destroyed=f,n.finished=s,n.length=o,n.pos=c,o%e&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const et=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),z=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),k=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Ht=BigInt(2**32-1),se=BigInt(32);function rn(t,n=!1){return n?{h:Number(t&Ht),l:Number(t>>se&Ht)}:{h:Number(t>>se&Ht)|0,l:Number(t&Ht)|0}}function on(t,n=!1){const e=t.length;let r=new Uint32Array(e),o=new Uint32Array(e);for(let s=0;s<e;s++){const{h:f,l:c}=rn(t[s],n);[r[s],o[s]]=[f,c]}return[r,o]}const fe=(t,n,e)=>t>>>e,ce=(t,n,e)=>t<<32-e|n>>>e,ht=(t,n,e)=>t>>>e|n<<32-e,bt=(t,n,e)=>t<<32-e|n>>>e,Nt=(t,n,e)=>t<<64-e|n>>>e-32,Ut=(t,n,e)=>t>>>e-32|n<<64-e;function X(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const sn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),fn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,cn=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),an=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,ln=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),dn=(t,n,e,r,o,s)=>n+e+r+o+s+(t/2**32|0)|0,un=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nt=new Uint32Array(64);class hn extends Se{constructor(n=32){super(64,n,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){const{A:n,B:e,C:r,D:o,E:s,F:f,G:c,H:i}=this;return[n,e,r,o,s,f,c,i]}set(n,e,r,o,s,f,c,i){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=c|0,this.H=i|0}process(n,e){for(let h=0;h<16;h++,e+=4)nt[h]=n.getUint32(e,!1);for(let h=16;h<64;h++){const p=nt[h-15],H=nt[h-2],q=W(p,7)^W(p,18)^p>>>3,w=W(H,17)^W(H,19)^H>>>10;nt[h]=w+nt[h-7]+q+nt[h-16]|0}let{A:r,B:o,C:s,D:f,E:c,F:i,G:d,H:x}=this;for(let h=0;h<64;h++){const p=W(c,6)^W(c,11)^W(c,25),H=x+p+en(c,i,d)+un[h]+nt[h]|0,w=(W(r,2)^W(r,13)^W(r,22))+nn(r,o,s)|0;x=d,d=i,i=c,c=f+H|0,f=s,s=o,o=r,r=H+w|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,c=c+this.E|0,i=i+this.F|0,d=d+this.G|0,x=x+this.H|0,this.set(r,o,s,f,c,i,d,x)}roundClean(){gt(nt)}destroy(){this.set(0,0,0,0,0,0,0,0),gt(this.buffer)}}const Ie=on(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),bn=Ie[0],wn=Ie[1],rt=new Uint32Array(80),ot=new Uint32Array(80);class He extends Se{constructor(n=64){super(128,n,16,!1),this.Ah=k[0]|0,this.Al=k[1]|0,this.Bh=k[2]|0,this.Bl=k[3]|0,this.Ch=k[4]|0,this.Cl=k[5]|0,this.Dh=k[6]|0,this.Dl=k[7]|0,this.Eh=k[8]|0,this.El=k[9]|0,this.Fh=k[10]|0,this.Fl=k[11]|0,this.Gh=k[12]|0,this.Gl=k[13]|0,this.Hh=k[14]|0,this.Hl=k[15]|0}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:s,Cl:f,Dh:c,Dl:i,Eh:d,El:x,Fh:h,Fl:p,Gh:H,Gl:q,Hh:w,Hl:T}=this;return[n,e,r,o,s,f,c,i,d,x,h,p,H,q,w,T]}set(n,e,r,o,s,f,c,i,d,x,h,p,H,q,w,T){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=f|0,this.Dh=c|0,this.Dl=i|0,this.Eh=d|0,this.El=x|0,this.Fh=h|0,this.Fl=p|0,this.Gh=H|0,this.Gl=q|0,this.Hh=w|0,this.Hl=T|0}process(n,e){for(let g=0;g<16;g++,e+=4)rt[g]=n.getUint32(e),ot[g]=n.getUint32(e+=4);for(let g=16;g<80;g++){const a=rt[g-15]|0,b=ot[g-15]|0,m=ht(a,b,1)^ht(a,b,8)^fe(a,b,7),A=bt(a,b,1)^bt(a,b,8)^ce(a,b,7),v=rt[g-2]|0,U=ot[g-2]|0,O=ht(v,U,19)^Nt(v,U,61)^fe(v,U,6),E=bt(v,U,19)^Ut(v,U,61)^ce(v,U,6),I=cn(A,E,ot[g-7],ot[g-16]),B=an(I,m,O,rt[g-7],rt[g-16]);rt[g]=B|0,ot[g]=I|0}let{Ah:r,Al:o,Bh:s,Bl:f,Ch:c,Cl:i,Dh:d,Dl:x,Eh:h,El:p,Fh:H,Fl:q,Gh:w,Gl:T,Hh:C,Hl:G}=this;for(let g=0;g<80;g++){const a=ht(h,p,14)^ht(h,p,18)^Nt(h,p,41),b=bt(h,p,14)^bt(h,p,18)^Ut(h,p,41),m=h&H^~h&w,A=p&q^~p&T,v=ln(G,b,A,wn[g],ot[g]),U=dn(v,C,a,m,bn[g],rt[g]),O=v|0,E=ht(r,o,28)^Nt(r,o,34)^Nt(r,o,39),I=bt(r,o,28)^Ut(r,o,34)^Ut(r,o,39),B=r&s^r&c^s&c,R=o&f^o&i^f&i;C=w|0,G=T|0,w=H|0,T=q|0,H=h|0,q=p|0,{h,l:p}=X(d|0,x|0,U|0,O|0),d=c|0,x=i|0,c=s|0,i=f|0,s=r|0,f=o|0;const u=sn(O,I,R);r=fn(u,U,E,B),o=u|0}({h:r,l:o}=X(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:f}=X(this.Bh|0,this.Bl|0,s|0,f|0),{h:c,l:i}=X(this.Ch|0,this.Cl|0,c|0,i|0),{h:d,l:x}=X(this.Dh|0,this.Dl|0,d|0,x|0),{h,l:p}=X(this.Eh|0,this.El|0,h|0,p|0),{h:H,l:q}=X(this.Fh|0,this.Fl|0,H|0,q|0),{h:w,l:T}=X(this.Gh|0,this.Gl|0,w|0,T|0),{h:C,l:G}=X(this.Hh|0,this.Hl|0,C|0,G|0),this.set(r,o,s,f,c,i,d,x,h,p,H,q,w,T,C,G)}roundClean(){gt(rt,ot)}destroy(){gt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class gn extends He{constructor(){super(48),this.Ah=z[0]|0,this.Al=z[1]|0,this.Bh=z[2]|0,this.Bl=z[3]|0,this.Ch=z[4]|0,this.Cl=z[5]|0,this.Dh=z[6]|0,this.Dl=z[7]|0,this.Eh=z[8]|0,this.El=z[9]|0,this.Fh=z[10]|0,this.Fl=z[11]|0,this.Gh=z[12]|0,this.Gl=z[13]|0,this.Hh=z[14]|0,this.Hl=z[15]|0}}const xn=Xt(()=>new hn),pn=Xt(()=>new He),yn=Xt(()=>new gn);class Ne extends ue{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Ze(n);const r=$t(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=n.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),gt(s)}update(n){return Lt(this),this.iHash.update(n),this}digestInto(n){Lt(this),Bt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:c}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=f,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ue=(t,n,e)=>new Ne(t,n).update(e).digest();Ue.create=(t,n)=>new Ne(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ae=BigInt(0),Pt=BigInt(1);function Vt(t,n){const e=n.negate();return t?e:n}function Le(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Mt(t,n){Le(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),o=2**t,s=Ct(t),f=BigInt(t);return{windows:e,windowSize:r,mask:s,maxNumber:o,shiftBy:f}}function le(t,n,e){const{windowSize:r,mask:o,maxNumber:s,shiftBy:f}=e;let c=Number(t&o),i=t>>f;c>r&&(c-=s,i+=Pt);const d=n*r,x=d+Math.abs(c)-1,h=c===0,p=c<0,H=n%2!==0;return{nextN:i,offset:x,isZero:h,isNeg:p,isNegF:H,offsetF:d}}function mn(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function En(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Gt=new WeakMap,Oe=new WeakMap;function Dt(t){return Oe.get(t)||1}function Bn(t,n){return{constTimeNegate:Vt,hasPrecomputes(e){return Dt(e)!==1},unsafeLadder(e,r,o=t.ZERO){let s=e;for(;r>ae;)r&Pt&&(o=o.add(s)),s=s.double(),r>>=Pt;return o},precomputeWindow(e,r){const{windows:o,windowSize:s}=Mt(r,n),f=[];let c=e,i=c;for(let d=0;d<o;d++){i=c,f.push(i);for(let x=1;x<s;x++)i=i.add(c),f.push(i);c=i.double()}return f},wNAF(e,r,o){let s=t.ZERO,f=t.BASE;const c=Mt(e,n);for(let i=0;i<c.windows;i++){const{nextN:d,offset:x,isZero:h,isNeg:p,isNegF:H,offsetF:q}=le(o,i,c);o=d,h?f=f.add(Vt(H,r[q])):s=s.add(Vt(p,r[x]))}return{p:s,f}},wNAFUnsafe(e,r,o,s=t.ZERO){const f=Mt(e,n);for(let c=0;c<f.windows&&o!==ae;c++){const{nextN:i,offset:d,isZero:x,isNeg:h}=le(o,c,f);if(o=i,!x){const p=r[d];s=s.add(h?p.negate():p)}}return s},getPrecomputes(e,r,o){let s=Gt.get(r);return s||(s=this.precomputeWindow(r,e),e!==1&&Gt.set(r,o(s))),s},wNAFCached(e,r,o){const s=Dt(e);return this.wNAF(s,this.getPrecomputes(s,e,o),r)},wNAFCachedUnsafe(e,r,o,s){const f=Dt(e);return f===1?this.unsafeLadder(e,r,s):this.wNAFUnsafe(f,this.getPrecomputes(f,e,o),r,s)},setWindowSize(e,r){Le(r,n),Oe.set(e,r),Gt.delete(e)}}}function An(t,n,e,r){mn(e,t),En(r,n);const o=e.length,s=r.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const f=t.ZERO,c=De(BigInt(o));let i=1;c>12?i=c-3:c>4?i=c-2:c>0&&(i=2);const d=Ct(i),x=new Array(Number(d)+1).fill(f),h=Math.floor((n.BITS-1)/i)*i;let p=f;for(let H=h;H>=0;H-=i){x.fill(f);for(let w=0;w<s;w++){const T=r[w],C=Number(T>>BigInt(H)&d);x[C]=x[C].add(e[w])}let q=f;for(let w=x.length-1,T=f;w>0;w--)T=T.add(x[w]),q=q.add(T);if(p=p.add(q),H!==0)for(let w=0;w<i;w++)p=p.double()}return p}function qe(t){return Xe(t.Fp),_t(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Be(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function de(t){t.lowS!==void 0&&mt("lowS",t.lowS),t.prehash!==void 0&&mt("prehash",t.prehash)}function vn(t){const n=qe(t);_t(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class Sn extends Error{constructor(n=""){super(n)}}const Q={Err:Sn,_tlv:{encode:(t,n)=>{const{Err:e}=Q;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,o=It(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");const s=r>127?It(o.length/2|128):"";return It(t)+s+o+n},decode(t,n){const{Err:e}=Q;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const o=n[r++],s=!!(o&128);let f=0;if(!s)f=o;else{const i=o&127;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+i);if(d.length!==i)throw new e("tlv.decode: length bytes not complete");if(d[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const x of d)f=f<<8|x;if(r+=i,f<128)throw new e("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+f);if(c.length!==f)throw new e("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+f)}}},_int:{encode(t){const{Err:n}=Q;if(t<J)throw new n("integer: negative integers are not allowed");let e=It(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=Q;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ct(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=Q,o=j("signature",t),{v:s,l:f}=r.decode(48,o);if(f.length)throw new n("invalid signature: left bytes after parsing");const{v:c,l:i}=r.decode(2,s),{v:d,l:x}=r.decode(2,i);if(x.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(d)}},hexFromSig(t){const{_tlv:n,_int:e}=Q,r=n.encode(2,e.encode(t.r)),o=n.encode(2,e.encode(t.s)),s=r+o;return n.encode(48,s)}};function Ft(t,n){return Et(vt(t,n))}const J=BigInt(0),Z=BigInt(1);BigInt(2);const jt=BigInt(3),In=BigInt(4);function Hn(t){const n=vn(t),{Fp:e}=n,r=St(n.n,n.nBitLength),o=n.toBytes||((g,a,b)=>{const m=a.toAffine();return qt(Uint8Array.from([4]),e.toBytes(m.x),e.toBytes(m.y))}),s=n.fromBytes||(g=>{const a=g.subarray(1),b=e.fromBytes(a.subarray(0,e.BYTES)),m=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:b,y:m}});function f(g){const{a,b}=n,m=e.sqr(g),A=e.mul(m,g);return e.add(e.add(A,e.mul(g,a)),b)}function c(g,a){const b=e.sqr(a),m=f(g);return e.eql(b,m)}if(!c(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const i=e.mul(e.pow(n.a,jt),In),d=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(i,d)))throw new Error("bad curve params: a or b");function x(g){return te(g,Z,n.n)}function h(g){const{allowedPrivateKeyLengths:a,nByteLength:b,wrapPrivateKey:m,n:A}=n;if(a&&typeof g!="bigint"){if(At(g)&&(g=Et(g)),typeof g!="string"||!a.includes(g.length))throw new Error("invalid private key");g=g.padStart(b*2,"0")}let v;try{v=typeof g=="bigint"?g:ct(j("private key",g,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof g)}return m&&(v=Y(v,A)),wt("private key",v,Z,A),v}function p(g){if(!(g instanceof w))throw new Error("ProjectivePoint expected")}const H=oe((g,a)=>{const{px:b,py:m,pz:A}=g;if(e.eql(A,e.ONE))return{x:b,y:m};const v=g.is0();a==null&&(a=v?e.ONE:e.inv(A));const U=e.mul(b,a),O=e.mul(m,a),E=e.mul(A,a);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:U,y:O}}),q=oe(g=>{if(g.is0()){if(n.allowInfinityPoint&&!e.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:a,y:b}=g.toAffine();if(!e.isValid(a)||!e.isValid(b))throw new Error("bad point: x or y not FE");if(!c(a,b))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(a,b,m){if(a==null||!e.isValid(a))throw new Error("x required");if(b==null||!e.isValid(b)||e.is0(b))throw new Error("y required");if(m==null||!e.isValid(m))throw new Error("z required");this.px=a,this.py=b,this.pz=m,Object.freeze(this)}static fromAffine(a){const{x:b,y:m}=a||{};if(!a||!e.isValid(b)||!e.isValid(m))throw new Error("invalid affine point");if(a instanceof w)throw new Error("projective point not allowed");const A=v=>e.eql(v,e.ZERO);return A(b)&&A(m)?w.ZERO:new w(b,m,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const b=Ee(e,a.map(m=>m.pz));return a.map((m,A)=>m.toAffine(b[A])).map(w.fromAffine)}static fromHex(a){const b=w.fromAffine(s(j("pointHex",a)));return b.assertValidity(),b}static fromPrivateKey(a){return w.BASE.multiply(h(a))}static msm(a,b){return An(w,r,a,b)}_setWindowSize(a){G.setWindowSize(this,a)}assertValidity(){q(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){p(a);const{px:b,py:m,pz:A}=this,{px:v,py:U,pz:O}=a,E=e.eql(e.mul(b,O),e.mul(v,A)),I=e.eql(e.mul(m,O),e.mul(U,A));return E&&I}negate(){return new w(this.px,e.neg(this.py),this.pz)}double(){const{a,b}=n,m=e.mul(b,jt),{px:A,py:v,pz:U}=this;let O=e.ZERO,E=e.ZERO,I=e.ZERO,B=e.mul(A,A),R=e.mul(v,v),u=e.mul(U,U),l=e.mul(A,v);return l=e.add(l,l),I=e.mul(A,U),I=e.add(I,I),O=e.mul(a,I),E=e.mul(m,u),E=e.add(O,E),O=e.sub(R,E),E=e.add(R,E),E=e.mul(O,E),O=e.mul(l,O),I=e.mul(m,I),u=e.mul(a,u),l=e.sub(B,u),l=e.mul(a,l),l=e.add(l,I),I=e.add(B,B),B=e.add(I,B),B=e.add(B,u),B=e.mul(B,l),E=e.add(E,B),u=e.mul(v,U),u=e.add(u,u),B=e.mul(u,l),O=e.sub(O,B),I=e.mul(u,R),I=e.add(I,I),I=e.add(I,I),new w(O,E,I)}add(a){p(a);const{px:b,py:m,pz:A}=this,{px:v,py:U,pz:O}=a;let E=e.ZERO,I=e.ZERO,B=e.ZERO;const R=n.a,u=e.mul(n.b,jt);let l=e.mul(b,v),y=e.mul(m,U),L=e.mul(A,O),S=e.add(b,m),N=e.add(v,U);S=e.mul(S,N),N=e.add(l,y),S=e.sub(S,N),N=e.add(b,A);let _=e.add(v,O);return N=e.mul(N,_),_=e.add(l,L),N=e.sub(N,_),_=e.add(m,A),E=e.add(U,O),_=e.mul(_,E),E=e.add(y,L),_=e.sub(_,E),B=e.mul(R,N),E=e.mul(u,L),B=e.add(E,B),E=e.sub(y,B),B=e.add(y,B),I=e.mul(E,B),y=e.add(l,l),y=e.add(y,l),L=e.mul(R,L),N=e.mul(u,N),y=e.add(y,L),L=e.sub(l,L),L=e.mul(R,L),N=e.add(N,L),l=e.mul(y,N),I=e.add(I,l),l=e.mul(_,N),E=e.mul(S,E),E=e.sub(E,l),l=e.mul(S,y),B=e.mul(_,B),B=e.add(B,l),new w(E,I,B)}subtract(a){return this.add(a.negate())}is0(){return this.equals(w.ZERO)}wNAF(a){return G.wNAFCached(this,a,w.normalizeZ)}multiplyUnsafe(a){const{endo:b,n:m}=n;wt("scalar",a,J,m);const A=w.ZERO;if(a===J)return A;if(this.is0()||a===Z)return this;if(!b||G.hasPrecomputes(this))return G.wNAFCachedUnsafe(this,a,w.normalizeZ);let{k1neg:v,k1:U,k2neg:O,k2:E}=b.splitScalar(a),I=A,B=A,R=this;for(;U>J||E>J;)U&Z&&(I=I.add(R)),E&Z&&(B=B.add(R)),R=R.double(),U>>=Z,E>>=Z;return v&&(I=I.negate()),O&&(B=B.negate()),B=new w(e.mul(B.px,b.beta),B.py,B.pz),I.add(B)}multiply(a){const{endo:b,n:m}=n;wt("scalar",a,Z,m);let A,v;if(b){const{k1neg:U,k1:O,k2neg:E,k2:I}=b.splitScalar(a);let{p:B,f:R}=this.wNAF(O),{p:u,f:l}=this.wNAF(I);B=G.constTimeNegate(U,B),u=G.constTimeNegate(E,u),u=new w(e.mul(u.px,b.beta),u.py,u.pz),A=B.add(u),v=R.add(l)}else{const{p:U,f:O}=this.wNAF(a);A=U,v=O}return w.normalizeZ([A,v])[0]}multiplyAndAddUnsafe(a,b,m){const A=w.BASE,v=(O,E)=>E===J||E===Z||!O.equals(A)?O.multiplyUnsafe(E):O.multiply(E),U=v(this,b).add(v(a,m));return U.is0()?void 0:U}toAffine(a){return H(this,a)}isTorsionFree(){const{h:a,isTorsionFree:b}=n;if(a===Z)return!0;if(b)return b(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:b}=n;return a===Z?this:b?b(w,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return mt("isCompressed",a),this.assertValidity(),o(w,this,a)}toHex(a=!0){return mt("isCompressed",a),Et(this.toRawBytes(a))}}w.BASE=new w(n.Gx,n.Gy,e.ONE),w.ZERO=new w(e.ZERO,e.ONE,e.ZERO);const{endo:T,nBitLength:C}=n,G=Bn(w,T?Math.ceil(C/2):C);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:h,weierstrassEquation:f,isWithinCurveOrder:x}}function Nn(t){const n=qe(t);return _t(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Un(t){const n=Nn(t),{Fp:e,n:r,nByteLength:o,nBitLength:s}=n,f=e.BYTES+1,c=2*e.BYTES+1;function i(u){return Y(u,r)}function d(u){return Wt(u,r)}const{ProjectivePoint:x,normPrivateKeyToScalar:h,weierstrassEquation:p,isWithinCurveOrder:H}=Hn({...n,toBytes(u,l,y){const L=l.toAffine(),S=e.toBytes(L.x),N=qt;return mt("isCompressed",y),y?N(Uint8Array.from([l.hasEvenY()?2:3]),S):N(Uint8Array.from([4]),S,e.toBytes(L.y))},fromBytes(u){const l=u.length,y=u[0],L=u.subarray(1);if(l===f&&(y===2||y===3)){const S=ct(L);if(!te(S,Z,e.ORDER))throw new Error("Point is not on curve");const N=p(S);let _;try{_=e.sqrt(N)}catch(K){const D=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+D)}const V=(_&Z)===Z;return(y&1)===1!==V&&(_=e.neg(_)),{x:S,y:_}}else if(l===c&&y===4){const S=e.fromBytes(L.subarray(0,e.BYTES)),N=e.fromBytes(L.subarray(e.BYTES,2*e.BYTES));return{x:S,y:N}}else{const S=f,N=c;throw new Error("invalid Point, expected length of "+S+", or uncompressed "+N+", got "+l)}}});function q(u){const l=r>>Z;return u>l}function w(u){return q(u)?i(-u):u}const T=(u,l,y)=>ct(u.slice(l,y));class C{constructor(l,y,L){wt("r",l,Z,r),wt("s",y,Z,r),this.r=l,this.s=y,L!=null&&(this.recovery=L),Object.freeze(this)}static fromCompact(l){const y=o;return l=j("compactSignature",l,y*2),new C(T(l,0,y),T(l,y,2*y))}static fromDER(l){const{r:y,s:L}=Q.toSig(j("DER",l));return new C(y,L)}assertValidity(){}addRecoveryBit(l){return new C(this.r,this.s,l)}recoverPublicKey(l){const{r:y,s:L,recovery:S}=this,N=A(j("msgHash",l));if(S==null||![0,1,2,3].includes(S))throw new Error("recovery id invalid");const _=S===2||S===3?y+n.n:y;if(_>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=(S&1)===0?"02":"03",P=x.fromHex(V+Ft(_,e.BYTES)),K=d(_),D=i(-N*K),at=i(L*K),tt=x.BASE.multiplyAndAddUnsafe(P,D,at);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return q(this.s)}normalizeS(){return this.hasHighS()?new C(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return Ot(this.toDERHex())}toDERHex(){return Q.hexFromSig(this)}toCompactRawBytes(){return Ot(this.toCompactHex())}toCompactHex(){const l=o;return Ft(this.r,l)+Ft(this.s,l)}}const G={isValidPrivateKey(u){try{return h(u),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const u=ve(n.n);return Je(n.randomBytes(u),n.n)},precompute(u=8,l=x.BASE){return l._setWindowSize(u),l.multiply(BigInt(3)),l}};function g(u,l=!0){return x.fromPrivateKey(u).toRawBytes(l)}function a(u){if(typeof u=="bigint")return!1;if(u instanceof x)return!0;const y=j("key",u).length,L=e.BYTES,S=L+1,N=2*L+1;if(!(n.allowedPrivateKeyLengths||o===S))return y===S||y===N}function b(u,l,y=!0){if(a(u)===!0)throw new Error("first arg must be private key");if(a(l)===!1)throw new Error("second arg must be public key");return x.fromHex(l).multiply(h(u)).toRawBytes(y)}const m=n.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const l=ct(u),y=u.length*8-s;return y>0?l>>BigInt(y):l},A=n.bits2int_modN||function(u){return i(m(u))},v=Ct(s);function U(u){return wt("num < 2^"+s,u,J,v),vt(u,o)}function O(u,l,y=E){if(["recovered","canonical"].some(it=>it in y))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:S}=n;let{lowS:N,prehash:_,extraEntropy:V}=y;N==null&&(N=!0),u=j("msgHash",u),de(y),_&&(u=j("prehashed msgHash",L(u)));const P=A(u),K=h(l),D=[U(K),U(P)];if(V!=null&&V!==!1){const it=V===!0?S(e.BYTES):V;D.push(j("extraEntropy",it))}const at=qt(...D),tt=P;function Tt(it){const lt=m(it);if(!H(lt))return;const Rt=d(lt),xt=x.BASE.multiply(lt).toAffine(),st=i(xt.x);if(st===J)return;const pt=i(Rt*i(tt+st*K));if(pt===J)return;let yt=(xt.x===st?0:2)|Number(xt.y&Z),dt=pt;return N&&q(pt)&&(dt=w(pt),yt^=1),new C(st,dt,yt)}return{seed:at,k2sig:Tt}}const E={lowS:n.lowS,prehash:!1},I={lowS:n.lowS,prehash:!1};function B(u,l,y=E){const{seed:L,k2sig:S}=O(u,l,y),N=n;return Fe(N.hash.outputLen,N.nByteLength,N.hmac)(L,S)}x.BASE._setWindowSize(8);function R(u,l,y,L=I){var yt;const S=u;l=j("msgHash",l),y=j("publicKey",y);const{lowS:N,prehash:_,format:V}=L;if(de(L),"strict"in L)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");const P=typeof S=="string"||At(S),K=!P&&!V&&typeof S=="object"&&S!==null&&typeof S.r=="bigint"&&typeof S.s=="bigint";if(!P&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let D,at;try{if(K&&(D=new C(S.r,S.s)),P){try{V!=="compact"&&(D=C.fromDER(S))}catch(dt){if(!(dt instanceof Q.Err))throw dt}!D&&V!=="der"&&(D=C.fromCompact(S))}at=x.fromHex(y)}catch{return!1}if(!D||N&&D.hasHighS())return!1;_&&(l=n.hash(l));const{r:tt,s:Tt}=D,it=A(l),lt=d(Tt),Rt=i(it*lt),xt=i(tt*lt),st=(yt=x.BASE.multiplyAndAddUnsafe(at,Rt,xt))==null?void 0:yt.toAffine();return st?i(st.x)===tt:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:b,sign:B,verify:R,ProjectivePoint:x,Signature:C,utils:G}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ln(t){return{hash:t,hmac:(n,...e)=>Ue(t,n,Ve(...e)),randomBytes:Me}}function ee(t,n){const e=r=>Un({...t,...Ln(r)});return{...e(n),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ce=St(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),On=Ce.create(BigInt("-3")),qn=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Cn=ee({a:On,b:qn,Fp:Ce,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},xn),_e=St(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),_n=_e.create(BigInt("-3")),Tn=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");ee({a:_n,b:Tn,Fp:_e,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},yn);const Te=St(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),Rn=Te.create(BigInt("-3")),Zn=BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");ee({a:Rn,b:Zn,Fp:Te,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1),lowS:!1,allowedPrivateKeyLengths:[130,131,132]},pn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zn=Cn;export{zn as p256};
